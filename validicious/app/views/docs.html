<div class="row top small">
  <div class="col-md-12">
    <div class="title">Documentation</div>
    <div class="subtitle">What is this? How do I use it? Will it do my laundry?</div>
  </div>
</div>

<div class="container doc">
  <div class="row">
    <div class="col-md-9">
      <div class="row doc-block first">
        <div class="col-md-12">
          <h2>Overview</h2>
          <p class="text-justify">
            Web applications are often decimated by complicated disaster zones of patched-together form validation.
            Many-a-tear have been shed by brave developers sent in to hit these abominations with a broken wrench
            until it does what the boss wants it to do.  These unorganized snippets of code generally suffer from a few
            common paradigms:
          </p>
          
          <div class="indent">
            <h4>The Pyramid of Doom</h4>
            <p class="text-justify">
              We've all seen it.  <samp>[10]</samp> A callback nested to a callback nested to a callback (<samp>GOTO 10</samp>).
              This style of coding has been appropriatly dubbed the <a href="http://tritarget.org/blog/2012/11/28/the-pyramid-of-doom-a-javascript-style-trap/">Pyramid of Doom</a> because,
              well, turn your head to the side and it looks like a pyramid:
              <div hljs language="js">its(function (data1) {
    very(function (data2) {
      annoying(function (data3) {
        toExamine(function (data4) {
          andUpdate(function (data5) {
            // some obscure processing here
          });
        });
      });
    });
  });</div>
              In terms of form validation, each of the callback functions generally performs one part of
              the validation, passing the result to the next callback.  This becomes extremely complex
              and difficult to manage as the validations change and evolve over time.  Apologies if
              the code snippet above bestowed any anxiety on you.
            </p>
            
            <h4>Huge Conditionals</h4>
            <p class="text-justify">
              While it may be a simple task to write a few function that test a piece of data for validity, the results
              of those functions aren't often aggregated in a helpful way.  This gives rise to huge chains of conditional
              statements that look ugly and require maintenance whenever the validation model changes.
              <div hljs no-escape language="js">if (hasMinLength(context, 5) && hasAlpha(context) && hasNumeric(context)
    && hasSpecialCharacter(context) && canBelieveItsNotButter(context)) {
    
    // did... did it pass?
  }</div>
            </p>
            
            <h4>Result Aggregation</h4>
            <p class="text-justify">
              Consider the conditional in the code snippet below.  Now imagine that one of those functions failed&mdash;the
              developer doesn't know <em>what</em> failed <em>why</em>.
              <div hljs no-escape language="js">if (hasMinLength(context, 5) && hasAlpha(context) && hasNumeric(context)) {
    // passed
  } else {
    // something failed... but what?
  }</div>
            </p>
            <p class="text-justify">
              The often-implemented, hacky way to deal with this issue is to refactor the code to something more like the following:
              <div hljs no-escape language="js">var errors = [];

  if (!hasMinLength(context, 5) errors.push('Needs minimum length of 5');
  if (!hasAlpha(context) errors.push('Needs a letter');
  if (!hasNumeric(context) errors.push('Needs a number');

  if (errors.length > 0) {
    alert('Failed because: ' + errors.join(', '));
  }</div>
              This model isn't scalable <em>or</em> maintainable.
            </p>
            
            <h4>Mixing Synchronous and Asynchronous Validations</h4>
            <p class="text-justify">
              This is the <em>coup de gr√¢ce</em> of bad validation practices.  Consider the last snippet of code we
              reluctantly glanced through.  Didn't read it?  Go back and burn it into your brain. Now, as bad as it is,
              it'll get even worse&mdash;consider adding an <em><strong>asynchronous</strong></em> check to this validation
              chain.  Everything falls apart like a brisket that's been in a slow-cooker for a year.
            </p>
            <p class="text-justify">
              Since you can't just synchronously go through all the checks and report their results anymore, you need
              to separate your validation into two new parts.  One part handles the synchronous validation, the other
              handles the asynchronous validation.  Remember the <strong>Pyramid of Doom</strong>?  That can happen here,
              too.  I'll include it for dramatic effect.
              <div hljs no-escape language="js">someSort(function (data1) {
    ofBadTest(function (data2) {
      var errors = [];
    
      if (data2 !== 'passed') {
        errors.push('The async thing failed');
      }
      
      if (!hasMinLength(context, 5) errors.push('Needs minimum length of 5');
    });
  });</div>
            </p>
            
            <p class="text-justify">
              Not feeling anxious yet?  Consider the fact that there might be multiple asynchronous validations.  You could
              get away with putting the synchronous validations in the final callback of the single asynchronous validation, but how are you going
              to handle two asynchronous validations? <small>(hint hint, it's a 3-dimensional triangle with a tragic future)</small>
            </p>
          </div>
          
          <h3>Validicious to the Rescue</h3>
          <p class="text-justify">
            Now we've seen some of the anti-patterns that plague much of the web.  Validicious was created to solve
            these problems, and make validation easier, cleaner, and more maintainable.  While it's original purpose
            is to process form data, it can also be used (and extended) to validate just about anything.
          </p>
          
          <p class="text-justify">
            Validicious lets you mix-and-match synchronous and asynchronous validation functions.  It takes care of the
            promises and all 
          </p>
        </div>
      </div>
    
      <div class="row doc-block first">
        <div class="col-md-12">
          <h2>Standard Validations</h2>
          <p class="text-justify">
            Validicious ships with two modes:
            <ul>
              <li><strong>Asynchronous</strong> with <code>Vds.async(...)</code></li>
              <li><strong>Synchronous</strong> with <code>Vds.sync(...)</code></li>
            </ul>
          </p>

          <h3>Asynchronous with <code>Vds.async(...)</code></h3>

          <p class="text-justify">
            <div hljs language="js" class="code-big">Vds.async(definition).then(function (summary) {
});</div>
          </p>

          <p class="text-justify">
            <code>Vds.async</code> takes a single parameter:
            <table class="table table-condensed">
              <tr>
                <td><kbd>definition</kbd></td>
                <td>Array</td>
                <td>The validation definition (see the <a href="#">Validation Definition</a> section for more information)</td>
              </tr>
            </table>
          </p>

          <p class="text-justify">
            <code>Vds.async</code> returns a <samp>promise</samp> that resolves once the validation is complete.  The resolving function provides a summary object (see the <a href="#">Summaries</a> section)
            that describes the results of the validation run.
          </p>

          <h3>Synchronous with <code>Vds.sync(...)</code></h3>

          <p class="text-justify">
            <div hljs language="js" class="code-big">var summary = Vds.sync(definition);</div>
          </p>

          <p class="text-justify">
            <code>Vds.sync</code> takes a single parameter:
            <table class="table table-condensed">
              <tr>
                <td><kbd>definition</kbd></td>
                <td>Array</td>
                <td>The validation definition (see the <a href="#">Validation Definition</a> section for more information)</td>
              </tr>
            </table>
          </p>

          <p class="text-justify">
            <code>Vds.sync</code> returns a summary object (see the <a href="#">Summaries</a> section) that describes the results of the validation run.
          </p>
        </div>
      </div>

      <div class="row doc-block">
        <div class="col-md-12">
          <h2>Quick Validations</h2>
          <p class="text-justify">
            You can use the two standard validation functions (<code>async()</code> and <code>sync()</code>) to do <em>quick validations</em> by using a different signature.  <strong>Quick
            validations are for running a single rule against a single context</strong>. They allow you to do simple validations without the need to use a more verbose validation definition.
          </p>

          <p class="text-justify">
            The following syntax will initiate a quick validation:

            <div hljs language="js" class="code-big">Vds.sync(context, rule, [options]);
Vds.async(context, rule, [options]);</div>

            <table class="table table-condensed">
              <tr>
                <td><kbd>context</kbd></td>
                <td>Any</td>
                <td>Input to validate</td>
              </tr>
              <tr>
                <td><kbd>rule</kbd></td>
                <td>String</td>
                <td>Name of the rule to execute</td>
              </tr>
              <tr>
                <td><kbd>options</kbd></td>
                <td>Object</td>
                <td>
                  <span class="text-danger">(Optional)</span>
                  Arguments to provide to the rule
                </td>
              </tr>
            </table>
          </p>

          <h3>Examples</h3>
          <div hljs language="js" class="code-big">Vds.sync($('#username').val(), 'min-length', { len: 5 });</div>
          <div hljs language="js" class="code-big">Vds.async($('#password').val(), 'has-alpha');</div>
        </div>
      </div>

      <div class="row doc-block">
        <div class="col-md-12">
          <h2>Validation Definitions</h2>

          <p class="text-justify">
            At the heart of every validation is the <em>validation definition</em>.  This is an array of <samp>check definitions</samp>, which in turn have arrays of <samp>rule definitions</samp>:
          </p>
          <div hljs language="js" class="code-big">var definition = [
  checkDefinition_1,
  checkDefinition_2,
  checkDefinition_3,
  ...
];</div>

          <h3>Check Definition</h3>
          <p class="text-justify">
            A <samp>check definition</samp> is an object that describes a set of rules to execute against a given context.
          </p>

          <p class="text-justify">
            <h4>Options</h4>
            <table class="table table-condensed">
              <tr>
                <td><kbd>context</kbd></td>
                <td>Any</td>
                <td>Input to validate.  This can also be a synchronous function that returns the input to be validated.</td>
              </tr>
              <tr>
                <td><kbd>rules</kbd></td>
                <td>Array</td>
                <td>A set of <samp>rule definitions</samp> that describe the rules to run against the given context</td>
              </tr>
              <tr>
                <td><kbd>alias</kbd></td>
                <td>String</td>
                <td><span class="text-danger">(Optional)</span> An internally-utilized ID to reference this check instance</td>
              </tr>
              <tr>
                <td><kbd>transform</kbd></td>
                <td>function(<samp>ctx</samp>)</td>
                <td><span class="text-danger">(Optional)</span> A function that takes the context as the parameter and returns a transformed version before it's sent to the rules</td>
              </tr>
              <tr>
                <td><kbd>ignore</kbd></td>
                <td>function()</td>
                <td><span class="text-danger">(Optional)</span> If this function returns <samp>true</samp>, then this check will be skipped during validation and will be marked as <span class="text-success">passed</span></td>
              </tr>
              <tr>
                <td><kbd>not</kbd></td>
                <td>Boolean</td>
                <td><span class="text-danger">(Optional)</span> Invert the result of the validation for this check</td>
              </tr>
            </table>
          </p>

          <h4>Example</h4>
          <div hljs language="js" class="code-big">var checkDefinition_1 = {
  context: #('#username').val(),
  alias: 'username',
  transform: function (context) {
    return context.toLowerCase();
  },
  ignore: function () {
    return (context === 'admin');
  },
  not: false,
  rules: [
    ruleDefinition_1,
    ruleDefinition_2,
    ruleDefinition_3,
    ...
  ]
}</div>

          <h3>Rule Definition</h3>
          <p class="text-justify">
            A <samp>rule definition</samp> is an object that describes a rule that will be executed against a given context with specified arguments.
          </p>

          <p class="text-justify">
            <h4>Options</h4>
            <table class="table table-condensed">
              <tr>
                <td><kbd>rule</kbd></td>
                <td>String</td>
                <td>Name of the rule</td>
              </tr>
              <tr>
                <td><kbd>alias</kbd></td>
                <td>String</td>
                <td><span class="text-danger">(Optional)</span> An internally-utilized ID to reference this rule instance</td>
              </tr>
              <tr>
                <td><kbd>transform</kbd></td>
                <td>function(<samp>ctx</samp>)</td>
                <td><span class="text-danger">(Optional)</span> A function that takes the context as the parameter and returns a transformed version to be used in the actual validation</td>
              </tr>
              <tr>
                <td><kbd>ignore</kbd></td>
                <td>function()</td>
                <td><span class="text-danger">(Optional)</span> If this function returns <samp>true</samp>, then this rule will be skipped during validation and will be marked as <span class="text-success">passed</span></td>
              </tr>
              <tr>
                <td><kbd>args</kbd></td>
                <td>Object</td>
                <td><span class="text-danger">(Optional)</span> Arguments that are consumed by the rule</td>
              </tr>
            </table>
          </p>

          <h4>Example</h4>
          <div hljs language="js" class="code-big">var ruleDefinition_1 = {
  rule: 'min-length',
  alias: 'username_min-length',
  transform: function (context) {
    return 'user' + context;
  },
  ignore: function () {
    return (context === 'admin');
  },
  args: {
    len: 8
  }
}</div>

        </div>
      </div>

      <div class="row doc-block">
        <div class="col-md-12">
          <h2>Summaries</h2>
          <div>
            <p class="text-justify">
              After Validicious has performed a validation, it will return a <em>Summary</em>.  A summary is a POJO that contains the validation result,
              the full validation definition, any payloads, and several methods to easily deal with this information.
            </p>

            <h4>Summary Properties</h4>
            <p class="text-justify">
              <table class="table table-condensed">
                <tr>
                  <td><kbd>result</kbd></td>
                  <td>Boolean</td>
                  <td>Result of the validation</td>
                </tr>
                <tr>
                  <td><kbd>checks</kbd></td>
                  <td>Array</td>
                  <td>All of the checks that were processed during the validation</td>
                </tr>
                <tr>
                  <td><kbd>passed</kbd></td>
                  <td>Array</td>
                  <td>All of the checks that passed</td>
                </tr>
                <tr>
                  <td><kbd>failed</kbd></td>
                  <td>Array</td>
                  <td>All of the checks that failed</td>
                </tr>
              </table>
            </p>

            <h4>Summary Methods</h4>
            <p class="text-justify">
              <table class="table table-condensed">
                <tr>
                  <td><kbd>.failedChecks()</kbd></td>
                  <td>Returns an array of checks that failed during the validation in an easy to consume format</td>
                </tr>
                <tr>
                  <td><kbd>.passededChecks()</kbd></td>
                  <td>Returns an array of checks that passed during the validation in an easy to consume format</td>
                </tr>
                <tr>
                  <td><kbd>.failedCheckAliases()</kbd></td>
                  <td>Returns an array of the aliases of the checks that failed</td>
                </tr>
                <tr>
                  <td><kbd>.passedCheckAliases()</kbd></td>
                  <td>Returns an array of the aliases of the checks that passed</td>
                </tr>
              </table>
            </p>
          </div>
        </div>
      </div>

      <div class="row doc-block">
        <div class="col-md-12">
          <h2>Writing Rules</h2>
          <div>
            <p class="text-justify">
              Writing custom rules in Validicious is easy as pie.
              <a href="http://www.foodnetwork.com/recipes/ina-garten/strawberry-rhubarb-crisp-recipe.html" target="_blank">Strawberry rhubarb</a>
              pie, to be unnecessarily specific.  Use this as a template to get you started:
            </p>

            <div hljs language="js" class="code-big">Vds.Rules.add('rule-name', function (rule, context, options) {
  return rule.finish(conditional, payload);
});</div>

            <p class="text-justify">
              A rule is just a plain old, totally not scary JavaScript function.  It is executed automatically by Validicious with three parameters:
              <table class="table table-condensed">
                <tr>
                  <td><kbd>rule</kbd></td>
                  <td>Rule</td>
                  <td>A reference to the rule object that is generated internally by Validicious</td>
                </tr>
                <tr>
                  <td><kbd>context</kbd></td>
                  <td>Any</td>
                  <td>The input that is being validated (this can be any data type)</td>
                </tr>
                <tr>
                  <td><kbd>options</kbd></td>
                  <td>Object</td>
                  <td>An object that supplies the arguments chosen to run with this rule</td>
                </tr>
              </table>
            </p>

            <p class="text-justify">
              To tell Validicious if the input to your rule passed or failed, return <code>rule.finish(...)</code>.  To cover both asynchronous and synchronous validations, your rule needs to
              both call this function <em>and</em> return the result.
            </p>

            <p class="text-justify">
              <code>rule.finish(result, payload)</code> takes two parameters:
              <table class="table table-condensed">
                <tr>
                  <td><kbd>result</kbd></td>
                  <td>Boolean</td>
                  <td>A boolean representing the result of the validation</td>
                </tr>
                <tr>
                  <td><kbd>payload</kbd></td>
                  <td>Any</td>
                  <td>Any additional data that should be supplied with the validation result</td>
                </tr>
              </table>
            </p>

            <p class="text-justify">
              If your rule is <em>only asynchronous</em> and is not applicable to synchronous validation, you do not need to return the result of <samp>rule.finish(...)</samp>.
            </p>
            
            <h3>Example</h3>
            <p class="text-justify">
              The following rule, <samp>divisible-by</samp>, will pass if the context is divisible by a given number (<samp>options.num</samp>).  The remainder (whatever
              is left after trying to divide the context) will be sent as the payload.
            </p>
            <div hljs language="js" class="code-big">Vds.Rules.add('divisible-by', function (rule, context, options) {
  var remainder = context % options.num;
  return rule.finish(remainder === 0, remainder);
});</div>
            <p class="text-justify">
              Now use Validicious normally, using this rule to test if the number in some input <samp>#number</samp> is divisible by 5.
              In this example, we will use <code>sync()</code> since we are only running a single rule
              and it isn't asynchronous.
            </p>
            <div hljs language="js" class="code-big">var result = Vds.sync({
  context: $('#number').val(),
  rules: [{
    rule: 'divisible-by',
    args: { num: 5 }
  }]
});</div>
            <p class="text-justify">
              Of course, since we are executing a single rule against a single context, we could shorten this by
              using the quick validation signature for <code>sync()</code> as follows:
            </p>
            
            <div hljs language="js" class="code-big">var result = Vds.sync($('#number').val(), 'divisible-by', { num: 5 });</div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-md-3">
      <nav class="docs-nav" data-spy="affix">
        <ul>
          <li><a href="#">Overview</a></li>
          <li><a href="#">Standard Validations</a></li>
          <li><a href="#">Quick Validations</a></li>
          <li><a href="#">Validation Definitions</a></li>
          <li><a href="#">Summaries</a></li>
          <li><a href="#">Writing Rules</a></li>
        </ul>
      </nav>
    </div>
  </div>
</div>